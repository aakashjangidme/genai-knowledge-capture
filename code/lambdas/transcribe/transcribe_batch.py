import json
import time
from datetime import datetime
from connections import Connections
from dataclasses import dataclass
from aws_lambda_powertools import Logger, Tracer, Metrics
from aws_lambda_powertools.utilities.typing import LambdaContext
from aws_lambda_powertools.utilities.parser import event_parser, BaseModel
from s3url import S3Url

is_cold_start = True
tracer = Tracer(service=Connections.service_name)
logger = Logger(
    service=Connections.service_name,
    log_uncaught_exceptions=True,
    serialize_stacktrace=True,
    namespace=Connections.namespace,
)
metrics = Metrics(service=Connections.service_name, namespace=Connections.namespace)


@dataclass
class Response:
    """
    A class for representing the output format of transcribe_batch Lambda

    Attributes:
    -----------
    statusCode: int
        A HTTP status code that denotes the output status of validation.
        A `200` values means validation completed successfully
    documentName: str
        User input document name
    transcribedFilesS3Uris: list
        List of S3 URIs of answer texts generated by Amazon Transcribe
    serviceName: str
        The name of the AWS Lambda as configured through AWS powertools
    """

    statusCode: int
    documentName: str
    transcribedFilesS3Uris: list
    serviceName: str = Connections.service_name


class Request(BaseModel):
    """
    A class for representing the input format of transcribe_batch Lambda

    Attributes:
    -----------
    statusCode: int
        A HTTP status code that denotes the output status of validation.
        A `200` values means validation completed successfully
    documentName: str
        User input document name
    audioFilesS3Uris: list
        List of S3 URIs of audio files to transcribe
    serviceName: str
        The name of the AWS Lambda as configured through AWS powertools
    """

    statusCode: int
    documentName: str
    audioFilesS3Uris: list
    serviceName: str


@tracer.capture_method
def generate_transcription_uri(audio_file_uri, output_directory_depth):
    """Generate transcription URI.

    Transcriptions will be stored in the same bucket as original audio file,
    under a folder named "transcribe". Can customize folder depth with
    output_directory_depth.

    Examples:

    directory depth 0
    s3://[bucket]/assets/audio/audio.mp3  ->
    s3://[bucket]/transcribe/assets/audio/transcription.txt

    directory depth 1
    s3://[bucket]/assets/audio/audio.mp3  ->
    s3://[bucket]/transcribe/audio/transcription.txt

    directory depth 2
    s3://[bucket]/assets/audio/audio.mp3  ->
    s3://[bucket]/assets/transcribe/transcription.txt

    directory depth 3
    s3://[bucket]/assets/audio/audio.mp3  ->
    s3://[bucket]/assets/audio/transcribe/transcription.txt
    """
    base_uri = S3Url(audio_file_uri)
    output_bucket = base_uri.bucket

    key_components = base_uri.key.split("/")
    if output_directory_depth == 0:
        key_components.insert(0, "transcribe")
    elif output_directory_depth >= len(key_components):
        key_components.insert(-1, "transcribe")
    else:
        key_components[output_directory_depth - 1] = "transcribe"

    filename = key_components[-1].split(".")
    filename[-1] = "txt"
    key_components[-1] = (".").join(filename)

    output_key = ("/").join(key_components)
    output_uri = f"s3://{output_bucket}/{output_key}"

    logger.info(f"Transcription URI: {output_uri}")
    return output_uri


@tracer.capture_method
def start_transcription(audio_file_uri, event):
    """Start transcription job with given audio file."""

    transcribe = Connections.transcribe_client
    audio_file = S3Url(audio_file_uri)

    # Generate unique transcription job name
    transcription_job_name = (
        audio_file.key.split("/")[-1].replace(".", "_").replace(" ", "_")
    )
    unique_job_name_suffix = datetime.now().strftime("%d-%m-%Y_%H-%M-%S")
    transcription_job_name = f"{transcription_job_name}_{unique_job_name_suffix}"

    logger.info(f"starting transcribe job: {transcription_job_name}")

    # Start transcription job
    try:
        return transcribe.start_transcription_job(
            TranscriptionJobName=transcription_job_name,
            LanguageCode="en-US",
            Media={"MediaFileUri": audio_file_uri},
            OutputBucketName=audio_file.bucket,
            OutputKey=f"transcribe_raw_output/{transcription_job_name}",
        )

    except Exception as e:
        response = Response(
            statusCode=400, documentName=event.documentName, transcribedFilesS3Uris=[]
        ).__dict__
        logger.exception("Unable to start Transcription job", e)
        return response


@tracer.capture_method
def process_transcription(
    job_name,
    audio_file_uri,
    event,
    job_timeout_seconds=180,
    initial_backoff_interval=10,
    max_backoff=60,
    output_directory_depth=0,
):
    """Retrieve transcript, put txt in S3, and return URI.
    If transcription is not finished, wait until specified timeout.
    """

    s3 = Connections.s3_client
    transcribe = Connections.transcribe_client
    wait_seconds_remaining = job_timeout_seconds
    backoff_interval = initial_backoff_interval  # Initial backoff interval in seconds

    while wait_seconds_remaining > 0:
        job = transcribe.get_transcription_job(TranscriptionJobName=job_name)
        job_status = job["TranscriptionJob"]["TranscriptionJobStatus"]

        if job_status in ["COMPLETED", "FAILED"]:
            if job_status == "COMPLETED":
                # Get transcript file URI
                job_result_uri = S3Url(
                    job["TranscriptionJob"]["Transcript"]["TranscriptFileUri"]
                )

                # Parsing to accommodate Transcribe S3 URL output format:
                job_bucket = job_result_uri.key.split("/")[0]
                job_key = ("/").join(job_result_uri.key.split("/")[1:])

                # Get contents from Transcribe-managed S3.
                job_result = s3.get_object(Bucket=job_bucket, Key=job_key)

                # From the transcription object, get only the transcript text
                transcript = json.loads(job_result["Body"].read().decode("utf-8"))[
                    "results"
                ]["transcripts"][0]["transcript"]

                # Upload transcript text to user's S3
                output_uri = S3Url(
                    generate_transcription_uri(audio_file_uri, output_directory_depth)
                )
                s3.put_object(
                    Body=transcript, Bucket=output_uri.bucket, Key=output_uri.key
                )

                return output_uri.url

            else:
                response = Response(
                    statusCode=400,
                    documentName=event.documentName,
                    transcribedFilesS3Uris=[],
                ).__dict__
                logger.exception("Transcription unsuccessful")
                return response

        # Wait for a bit before retrying
        time.sleep(backoff_interval)  # nosem: arbitrary-sleep
        # Exponentially increase the backoff interval, up to the max_backoff limit
        backoff_interval = min(max_backoff, backoff_interval * 2)

        # Reduce the remaining wait time
        wait_seconds_remaining -= backoff_interval

    # If the function exits the while loop because time ran out, return a timeout response
    response = Response(
        statusCode=400, documentName=event.documentName, transcribedFilesS3Uris=[]
    ).__dict__
    logger.exception("Transcribe lambda timed out")
    return response


@logger.inject_lambda_context(log_event=True, clear_state=True)
@tracer.capture_lambda_handler
@metrics.log_metrics(capture_cold_start_metric=True)
@event_parser(model=Request)
def lambda_handler(event: Request, context: LambdaContext):
    """
    Calls transcribe to extract text from audio.

    Arguments:
    ----------
        event (dict): input data
        context (LambdaContext): This object provides methods and
            properties that provide information about the invocation,
            function, and execution environment.

    Returns:
    --------
        dict: Returns a JSON or dict object; see Response class for format.
    """
    logger.debug(f"events: {event}")
    logger.info("Running transcribe_batch lambda")
    logger.debug(f"audioFilesS3Uris: {event.audioFilesS3Uris}")

    # Start all transcription jobs.
    # As of Apr 3 2024, Transcribe supports 250 concurrent batch jobs per region
    logger.info("Starting transcription jobs")
    job_names = {}
    for audio_file_uri in event.audioFilesS3Uris:
        response = start_transcription(audio_file_uri, event)

        if isinstance(response, dict):
            job_names[audio_file_uri] = response["TranscriptionJob"][
                "TranscriptionJobName"
            ]
        else:
            # If we don't receive job info dictionary, we must've encountered an error.
            # Return the error object directly.
            return response

    # Wait for transcriptions to finish.
    # Upload transcripts as .txt files in S3
    logger.info("Waiting for transcriptions to finish")
    transcription_uris = []
    for i, (audio_file_uri, job) in enumerate(job_names.items()):
        response = process_transcription(
            job, audio_file_uri, event, output_directory_depth=2
        )

        if isinstance(response, str):
            transcription_uris.append(response)
        else:
            # If we don't receive a string, we must've encountered an error.
            return response

    logger.info("Transcribe lambda finished successfully.")
    return Response(
        statusCode=200,
        documentName=event.documentName,
        transcribedFilesS3Uris=transcription_uris,
    ).__dict__
